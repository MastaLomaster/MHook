#include <Windows.h>
#include "MHKeypad.h"
#include "Settings.h"

extern HWND		MHhwnd; // Нужна для установки таймера
extern LONG screen_x, screen_y; // Для определения углов экрана
extern bool flag_inside_window; // Определён в оконной процедуре, показывает, что мы внутри окна
bool flag_scroll_started=false;


bool flag_left_button_key=false;
bool flag_stop_emulation=false;

bool flag_left_button_waits=false;
bool flag_right_button_waits=false;

static DWORD last_right_down_time;

//static DWORD last_screen_top_time;
int top_position=-1; // 0 - левый верхний угол, 1- правый верхний угол, -1 - убрали
//static bool mid_button_down=false;

static bool right_button_down=false;
static bool left_button_down=false;

//====================================================================================
// Собственно, хук 
//====================================================================================
LRESULT  CALLBACK HookProc(int disabled,WPARAM wParam,LPARAM lParam) 
{
	
    if (!disabled)
	{
		MOUSEHOOKSTRUCT * pMouseStruct = (MOUSEHOOKSTRUCT *)lParam;
		if (pMouseStruct != NULL)
		{
			switch(wParam)
			{
			case WM_MOUSEMOVE:
				//if(pMouseStruct->pt.x+pMouseStruct->pt.y<5) // А находимся ли мы в верхнем левом углу экрана?
				if((pMouseStruct->pt.y-pMouseStruct->pt.x>(screen_y-1)-5)) // А находимся ли мы в нижнем левом углу экрана?
				{
					// Запускаем таймер, только если пришли в угол снаружи!!!
					if(0!=top_position) SetTimer(MHhwnd,2,MHSettings::timeout_mouse_switch,NULL); // 
					top_position=0;
					// это ваще не надо last_screen_top_time=timeGetTime();
				} 
				//else if(pMouseStruct->pt.x-pMouseStruct->pt.y>screen_x-5) // Правый верхний угол
				else if(pMouseStruct->pt.x+pMouseStruct->pt.y>(screen_x-1)+(screen_y-1)-5) // Правый нижний угол
				{
					// Запускаем таймер, только если пришли в угол снаружи!!!
					if(1!=top_position) SetTimer(MHhwnd,2,MHSettings::timeout_mouse_switch,NULL);
					//top_position=0; // Пока дублируем левый верхний угол
					top_position=1; 
				}
				else if((top_position!=-1)&&(pMouseStruct->pt.y<screen_y)&&(pMouseStruct->pt.y>=0)&&
					(pMouseStruct->pt.x<screen_x)&&(pMouseStruct->pt.x>=0)) // Ждали окончания сигнала таймера, но уехали из угла
					// не рассматриваем выход за границы экрана
				{
					KillTimer(MHhwnd,2);
					top_position=-1;
				}

				// Обычная обработка - но теперь с оговоркой: двойной щелчок правой мог остановить эмуляцию!
				if(!flag_stop_emulation)
				{
					if(MHSettings::hh)
					{
						if(!flag_scroll_started) 
						{
							MHSettings::hh->OnMouseMove(pMouseStruct->pt.x, pMouseStruct->pt.y);
						}
						else MHSettings::hh->OnMouseScroll(pMouseStruct->pt.x, pMouseStruct->pt.y);
					}
				}

				// Флаг запрещает двигать мышь, когда нажата правая кнопка
				if((right_button_down)&&(MHSettings::flag_no_move_right_mb)) return 1;
				break;

			case WM_MBUTTONDOWN:
			case WM_RBUTTONDOWN:
				right_button_down=true;
				if(MHSettings::hh)
				{
					if(left_button_down) // Обе кнопки нажаты - начинаем режим скролла
					{
						flag_scroll_started=true;
						if(MHSettings::hh) MHSettings::hh->Deinitialize();
						return 1;
					}

					if(MHSettings::flag_right_mb_iskey) 
					{
						// Только если ещё не действует таймер!
						if(!flag_right_button_waits)
						{
							MHKeypad::Press4(10,true);
							//if(MHSettings::flag_right_mb_push_twice) MHKeypad::Press4(10,false); // Это если мы при отпускании мыши жмём клавишу ещё раз
							if(MHSettings::flag_right_mb_push_twice)
							{
								SetTimer(MHhwnd,4,MHSettings::timeout_mouse_click,NULL); // Это если мы при отпускании мыши жмём клавишу ещё раз
								flag_right_button_waits=true;
							}
						}
					}
					else MHSettings::hh->OnRDown();
					
					// Заплаточка: двойной щелчок переводит левую кнопку мыши в другое состояние
					if(MHSettings::flag_right_mb_doubleclick)
					{
						DWORD this_time=timeGetTime();
						if(this_time-last_right_down_time<500) // 1/2 секунды
						{
#ifdef _DEBUG
		 OutputDebugString("Двойной щелчок правой\n");
#endif
							
							// Переключаем режим эмуляции
							if(flag_stop_emulation) flag_stop_emulation=false;
							else
							{
								flag_stop_emulation=true;
								if(MHSettings::hh) MHSettings::hh->Deinitialize();
							}
						}
						last_right_down_time=this_time;
					}
					


					// Правую кнопку мыши подавляем
					return 1;
				}
				break;

			case WM_MBUTTONUP:
			case WM_RBUTTONUP:
				right_button_down=false;

				// Возможно, мы ждали отпускания мыши после двойного щелчка
				if(flag_stop_emulation) flag_stop_emulation=false;

				if(flag_scroll_started)
				{
					flag_scroll_started=false;
					if(MHSettings::hh) MHSettings::hh->Deinitialize();
					return 1; // подавляем, так как подавили нажатие
				}

				if(MHSettings::hh)
				{
					if(MHSettings::flag_right_mb_iskey) 
					{
						if(MHSettings::flag_right_mb_push_twice) 
						{
							// Только если ещё не действует таймер!
							if(!flag_right_button_waits)
							{
								MHKeypad::Press4(10,true); // Это если мы при отпускании мыши жмём клавишу ещё раз
								SetTimer(MHhwnd,4,MHSettings::timeout_mouse_click,NULL); 
								flag_right_button_waits=true;
							}
						}
						else MHKeypad::Press4(10,false);
					}
					else MHSettings::hh->OnRUp();


					// Правую кнопку мыши подавляем
					return 1;
				}
				break;

			case WM_LBUTTONDOWN:
				left_button_down=true;
				// Проверим, не собираемся ли мы ткнуть в наш квадратик?
				// Что означает начало скролла
				//if((flag_left_button_key)&&(flag_inside_window))
				if((flag_inside_window)||(right_button_down))
				{
					flag_scroll_started=true;
					if(MHSettings::hh) MHSettings::hh->Deinitialize();
					return 1;
				}
				// Нет, это не начало скролла, обрабатываем по обычному
				else if((flag_left_button_key)&&(MHSettings::hh))
				{
					MHSettings::hh->OnLDown(); 
					return 1;
				}
				break; 

			case WM_LBUTTONUP:
				left_button_down=false;
				// Таперича включение левой кнопки мыши 
			/*	if(MHSettings::timeout_mouse_switch<timeGetTime()-last_left_down_time) // смена режима
				{
					Beep(450,100);
					
					if(flag_left_button_key)
					{
						MHSettings::hh->OnLUp();
						flag_left_button_key=false;
						return 1;
					}
					else 
					{
						flag_left_button_key=true;
						break; // позволить обработать отпускание мыши системе, мы ещё не перехватили её нажатие, не трогаем и отпускание
					}
				}
			*/
				if(flag_scroll_started)
				{
					flag_scroll_started=false;
					if(MHSettings::hh) MHSettings::hh->Deinitialize();
					return 1; // подавляем, так как подавили нажатие
				}
				else if(flag_left_button_key) // держали недолго
				{
					MHSettings::hh->OnLUp();
					return 1;
				}
				break;

			}


		}

    }
	return CallNextHookEx(NULL,disabled,wParam,lParam);
}